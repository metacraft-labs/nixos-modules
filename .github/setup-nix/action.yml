name: Setup Nix
description: Installs Nix, configures binary caches, and optionally builds/activates a development environment using direnv or a specific Nix devShell.

inputs:
  push-to-cache:
    description: Whether to use cachix or not
    type: boolean
    required: false
    default: false
  cachix-cache:
    description: The name of the cachix cache to use
    required: true
  cachix-auth-token:
    description: Cachix auth token
    required: true
  trusted-public-keys:
    description: Trusted public keys
    required: false
    default: ''
  substituters:
    description: Substituters
    required: false
    default: ''
  nix-github-token:
    description: GitHub token to add as access-token in nix.conf
    default: ''
    required: false
  nix-gitlab-token:
    description: GitLab token to add as access-token in nix.conf
    default: ''
    required: false
  nix-gitlab-domain:
    description: GitLab domain to add as access-token in nix.conf
    default: 'gitlab.com'
    required: false
  nix-version:
    description: Nix version to install
    default: ''
    required: false
  use-direnv:
    description: Whether to use direnv to load the environment
    type: boolean
    required: false
    default: false
  devshell:
    description: The name of the devShell to build and export to GITHUB_ENV (e.g. 'default' for .#devShells.default)
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Log GH API rate limits
      env:
        GH_TOKEN: ${{ github.token }}
      shell: bash
      run: |
        echo "::group::GH API rate limits"
        gh api /rate_limit | jq || true
        echo "::endgroup::"

    - name: Install Nix
      uses: cachix/install-nix-action@v31
      if: ${{ runner.environment == 'github-hosted' }}
      with:
        install_url: ${{ inputs.nix-version != '' && format('https://releases.nixos.org/nix/nix-{0}/install', inputs.nix-version) || '' }}

    - name: Configure Nix
      shell: bash
      run: |
        mkdir -p $HOME/.config/nix

        cat << EOF > "$HOME/.config/nix/nix.conf"
          ${{
            (inputs.nix-github-token != '' && inputs.nix-gitlab-token != '' && inputs.nix-gitlab-domain != '' &&
              format('access-tokens = github.com={0} {1}=PAT:{2}', inputs.nix-github-token, inputs.nix-gitlab-domain, inputs.nix-gitlab-token)) ||
            (inputs.nix-github-token != '' &&
              format('access-tokens = github.com={0}', inputs.nix-github-token)) ||
            (inputs.nix-gitlab-token != '' && inputs.nix-gitlab-domain != '' &&
              format('access-tokens = {0}=PAT:{1}', inputs.nix-gitlab-domain, inputs.nix-gitlab-token)) ||
            ''
          }}

          fallback = true
          download-attempts = 2
          connect-timeout = 5
          narinfo-cache-negative-ttl = 120
          allow-import-from-derivation = true

          substituters = https://cache.nixos.org ${{inputs.substituters}}
          trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= ${{inputs.trusted-public-keys}}
          netrc-file = $HOME/.config/nix/netrc"
        EOF

        cat << EOF > "$HOME/.config/nix/netrc"
          machine ${{inputs.cachix-cache}}.cachix.org password ${{inputs.cachix-auth-token}}
        EOF

    - uses: cachix/cachix-action@v15
      if: ${{ fromJSON(inputs.push-to-cache || 'false') }}
      with:
        name: ${{ inputs.cachix-cache }}
        authToken: ${{ inputs.cachix-auth-token }}

    - name: Build & activate the Nix Dev Shell
      if: ${{ fromJSON(inputs.use-direnv || 'false') || inputs.devshell != '' }}
      shell: bash
      run: |
        direnv() { nix run --inputs-from . nixpkgs#direnv -- "$@"; }

        if [ "${{ inputs.devshell }}" != "" ] && [ "${{ inputs.use-direnv }}" == "true" ]; then
          echo "Error: 'devshell' and 'use-direnv' are mutually exclusive."
          exit 1
        fi

        if [ "${{ inputs.devshell }}" != "" ]; then
          # Function to restore .envrc
          restore_envrc() {
            if git ls-files --error-unmatch .envrc > /dev/null 2>&1; then
              git restore .envrc
            else
              rm -f .envrc
            fi
          }
          # Set trap to restore .envrc on exit (success or failure)
          trap restore_envrc EXIT

          echo "use flake .#${{ inputs.devshell }}" > .envrc
        elif [ "${{ inputs.use-direnv }}" == "true" ]; then
          if [ ! -f .envrc ]; then
            echo "Error: 'use-direnv' is enabled but .envrc does not exist."
            exit 1
          fi
        fi

        direnv allow .
        echo "::group::Building Nix DevShell"
        direnv export gha >> "$GITHUB_ENV"
        echo "::endgroup::"
